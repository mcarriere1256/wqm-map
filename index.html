<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="content-type" content="text/html; charset=UTF-8" />
		<meta name="viewport" content="initial-scale=1.0, user-scalable=no" />
		<link rel="stylesheet" href="https://cartodb-libs.global.ssl.fastly.net/cartodb.js/v3/3.15/themes/css/cartodb.css"></link>
		<script src="https://cartodb-libs.global.ssl.fastly.net/cartodb.js/v3/3.15/cartodb.js"></script>
		<script src="https://leaflet.github.io/Leaflet.label/leaflet.label.js"></script> <!-- files necessary for labels in leaflet -->
		<script type="text/javascript" src="https://stamen-maps.a.ssl.fastly.net/js/tile.stamen.js"></script><!--Include Stamen JavaScript to get basemap tiles-->
		
		<!-- Include the include files: global vars and display text -->
		<script src="global.js" type="text/javascript" /></script>
		<script src="display_English.js" type="text/javascript"></script>
		
		<!-- Include the CSS styling -->
		<link rel="stylesheet" type="text/css" href="map_styles.css"></link>
		
		<!-- Include both libraries for plotting stamen basemaps --> 
		<script type="text/javascript" src="https://stamen-maps.a.ssl.fastly.net/js/tile.stamen.js"></script><!--Include Stamen JavaScript to get basemap tiles-->
		
		<!-- Include stuff required for easy full-screen option --> 
		<script src='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/Leaflet.fullscreen.min.js'></script>
		<link href='https://api.mapbox.com/mapbox.js/plugins/leaflet-fullscreen/v1.0.1/leaflet.fullscreen.css' rel='stylesheet' />
		
	</head>
	
	<body onload="init();"> 	<!-- what to do when the page loads -->
		<div id='WaterMap'> 	<!-- creates the div element that holds the map -->
			<a href="http://www.caminosdeagua.org" target='_blank'> <!-- Link the caminos logo to the caminos website -->
				<img class="caminos_logo" src="https://dl.dropboxusercontent.com/s/ligsjij2ka26gi0/caminos_logo_circle.png" ></img> <!-- creates the caminos de agua logo -->
			</a>
			<div class="dropdown"> <!-- this next block of code creates the dropdown menu --> 
				<button id="DDHeader" onclick="toggleDD();" class="dropbtn", id="loading_indicator"></button> <!-- what to do when dropdown button is pressed -->
				<div id="mapSelector" class="dropdown-content">
					<a onclick="loadAndPlotData(FLUORIDE);" name="contam_button"></a> <!-- what to do when a contaminant/map layer is selected -->
					<a onclick="loadAndPlotData(ARSENIC);" name="contam_button"></a>        
					<a onclick="loadAndPlotData(TOTAL_RISK);" name="contam_button"></a>
				</div>
			</div>
			<!-- The next few chunks of code create the specific map legends. They're directly
			copy/pasted from carto.com. To add a new one, make your legend in carto, then, in
			the 'legend' tab of the map-view, view the html source code for your legend. Copy
			and paste it below.
				Alternately, you can copy and paste one of the legend div elements from below
			and reformat it to suit the needs of the contaminant you want to display. -->
			
			<!-- The legend for fluoride -->
			<div class='cartodb-legend density' id='fluoride_legend' style='display: none'>  
				<ul>
					<li class="min" style="text-transform:none" id="f_title"></li>
					<li class="graph leg" style="border-radius: 0; border:none">
						<div class="colors">
							<div class="quartile" style="background-color:#909090; width: 10px;" ></div>
							<div class="quartile" style="background-color:#229A00"></div>
							<div class="quartile" style="background-color:#FF9900"></div>
							<div class="quartile" style="background-color:#F11810"></div>
							<div class="quartile" style="background-color:#000000"></div>
						</div>
						<div class="colors" style="font-weight:normal; text-align: center">
							<div class="quartile" style="padding-top: 5px; text-transform: none; width: 10px;" name="no_data"></div>
							<div class="quartile" style="padding-top: 5px" name="f"></div>
							<div class="quartile" style="padding-top: 5px" name="f"></div>
							<div class="quartile" style="padding-top: 5px" name="f"></div>
							<div class="quartile" style="padding-top: 5px" name="f"></div>
						</div>
					</li>
				</ul>
			</div>
			
			<!-- The legend for arsenic -->
			<div class='cartodb-legend density' id='arsenic_legend' style='display: none'>  
				<ul>
					<li class="min" id="as_title" style="text-transform:none" ></li>
					<li class="graph leg" style="border-radius: 0; border:none">
						<div class="colors">
							<div class="quartile" style="background-color:#909090" name="greybar"></div>
							<div class="quartile" style="background-color:#229A00"></div>
							<div class="quartile" style="background-color:#FF9900"></div>
							<div class="quartile" style="background-color:#F11810"></div>
						</div>
						<div class="colors" style="font-weight:normal; text-align: center">
							<div class="quartile" style="padding-top: 5px; text-transform: none" name="no_data"><b></b></div>
							<div class="quartile" style="padding-top: 5px" name="as"></div>
							<div class="quartile" style="padding-top: 5px" name="as"></div>
							<div class="quartile" style="padding-top: 5px" name="as"></div>
						</div>
					</li>
				</ul>
			</div>
			
			<!-- The legend for the Total Risk map -->
			<div class='cartodb-legend custom' id='risk_legend' style="display: none">	
				<div class="legend-title", id="risk_title" style="text-transform:none"></div>
				<ul>
					<li>
						<div class="bullet" style="background:#229A00; text-transform:none" name="risk"></div> 
					</li>
					<li>
						<div class="bullet" style="background:#FFA300; text-transform:none" name="risk"></div>
					</li>
					<li>
						<div class="bullet" style="background:#F11810; text-transform:none" name="risk"></div>
					</li>
					<li>
						<div class="bullet" style="background:#000000; text-transform:none" name="risk"></div>
					</li>
				</ul>
			</div>
			
		</div>
		<!-- This upcoming script tag holds all of the functions and scripts that
		will run. If something isn't in a function, it runs automatically on load.
		Those are mostly global variable and CONSTANT definitions. If a variable's 
		value is constant, it is declared in BLOCK_LETTERS (with underscores between
		words). This is just a personal convention I use to avoid getting confused. 
		if a variable's value can change, its written with the first
		word beginning in lowercase, and the rest beginning upper, as in: helloThereYou. 
		Sometimes i depart from this convention for various reasons. For this, I appologize. =)
			The functions only run when they're called, either by the html code above,
		by another function, or by a user event like a click or zoom. -->
		<script>
		
			////////////////////////////////////////////////////////////////////////////////
			////					 DEFINE GLOBAL VARIABLES 						  	////
			////																		////
			////	IF YOU'RE TRYING TO CHANGE THE FORMATTING / COLORS / STYLES /		////
			////		DATASET IN THE EXISTING MAP, YOU SHOULD ONLY NEED TO CHANGE 	////
			////		STUFF IN THIS SECTION. DON'T CHANGE ANYTHING ELSE IF YOU'RE		////
			////		NOT SURE WHAT IT DOES!!!										////
			////																		////
			////	IF YOU WANT TO CHANGE SOMETHING FUNDAMENTAL, LIKE WHICH VARIABLES 	////
			////		CAN BE PLOTTED WITH THR DROPDOWN MENU, PLEASE REFFER TO THE 	////
			////		TUTORIAL VIDEO POSTED ON TRELLO BEFORE PROCEEDING. 				////
			////																		////
			////////////////////////////////////////////////////////////////////////////////
			
			for (k=0; k<BASE_URLS.length; k++) {  	// Grab all the icons with correct size. 
				BASE_ICONS[k] = L.icon({ 			// 	to be used when displaying the base markers
					iconUrl: BASE_URLS[k],
					iconSize: SMALL_ICON_SIZE
				});
				SPIDER_ICONS[k] = L.icon({ 			//	and the spidered markers
					iconUrl: SPIDER_URLS[k],
					iconSize: SMALL_ICON_SIZE
				});
				BASE_SPIDER_ICONS[k] = L.icon({		// 	and the markers at the base of the spider. 
					iconUrl: SPIDER_URLS[k],
					iconSize: LARGE_ICON_SIZE
				});
			};
			
			var X_ICON = L.icon({ 					// define an icon that can be clicked to close the spider
				iconUrl: X_URL,
				iconSize: SMALL_ICON_SIZE
			});
			
			for (var i=0; i<document.getElementsByName("no_data").length; i++) {
				document.getElementsByName("no_data")[i].innerHTML = "<b>"+NO_DATA_MSG+"</b>";
			}
			
			for (var i=0; i<document.getElementsByName("f").length; i++) {
				document.getElementsByName("f")[i].innerHTML = "<b>"+F_LABELS[i]+"</b>";
			}
			
			for (var i=0; i<document.getElementsByName("as").length; i++) {
				document.getElementsByName("as")[i].innerHTML = "<b>"+AS_LABELS[i]+"</b>";
			}
			
			for (var i=0; i<document.getElementsByName("risk").length; i++) {
				document.getElementsByName("risk")[i].innerHTML = RISK_LABELS[i];
			}
			
			for (var i=0; i<document.getElementsByName("contam_button").length; i++) {
				document.getElementsByName("contam_button")[i].innerHTML = CONTAMINANTS[i];
			}
			
			document.getElementById("f_title").innerHTML = F_TITLE;
			document.getElementById("as_title").innerHTML = AS_TITLE;
			document.getElementById("risk_title").innerHTML = RISK_TITLE;
			
			
			
			////////////////////////////////////////////////////////////////////////////////
			////					 INITIALIZATION FUNCTION 						  	////
			//////////////////////////////////////////////////////////////////////////////// 

			function init() {
				
				initMap(); 					// Initialize and display the map object
				applyBaseMap(); 			// Apply the base tiles to the map
				loadAndPlotData(TOTAL_RISK); 	// Load the data for Fluoride (the default contaminant) 
			}								// 	then plot the base markers on the map.	
			
			////////////////////////////////////////////////////////////////////////////////
			////					  	initMap FUNCTION	 						  	////
			//// 			This function initializes the global map object.			////
			////////////////////////////////////////////////////////////////////////////////
			
			function initMap() {
				map = new L.map('WaterMap', { //First, initialize the map
					center: MAP_CENTER,
					zoom: MAP_INIT_ZOOM,
					minZoom: MAP_MIN_ZOOM,
					maxZoom: MAP_MAX_ZOOM,
					attributionControl: true,
					fullscreenControl:true
				});	
				map.attributionControl.setPrefix(CARTO_ATTRIBUTION);
				map.on('zoomstart', function() { 	// When the map zooms,
					if (spiderOpen) {				//	if some points are spidered open,
						closeSpider();				//	close them,
						spiderOpen = true;			//	but save the status that they were open.
					};
				});
				
				map.on('zoomend', function() {	 	// Then when the map finishes zooming,
					if (spiderOpen) {				// 	if there were previously spidered points open,
						openSpider(AllData, spiderOpenIndex, activeContaminant);
					};								// 	re-open the same points at the current zoom level. 
				});
				
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					  	applyBaseMap FUNCTION 						  	////
			//// 	This function grabs a set of Stamen or Mapzen base tiles and 		////
			//// 	applies them to the map. 											////
			////////////////////////////////////////////////////////////////////////////////
			
			
			function applyBaseMap() {
				map.addLayer(new L.StamenTileLayer(STAMEN_MAP_TYPE), {});
				
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	loadAndPlotData FUNCTION 					  	////
			//// 	This function grabs data from carto.com and stores it in a local 	////
			//// 	variable array. It also stores a copy of the data in the global 	////
			////	array AllData for other functions to access. After storing the 		////
			////	data, it calls functions to plot them. 								////
			////////////////////////////////////////////////////////////////////////////////
			
			function loadAndPlotData(contaminantToShow) {
				base = { 							// reinitialize the global variable base.
					Markers: [],
					Popups: [],
					Bins: []
				};
				if (spiderOpen) {					// if there's a spider open, 
					closeSpider(); 					//	close the spider,
					spiderOpen = true;				//	but store that the spider is still open. 
				};									// (we'll open it back up later...)
				dup_indices = []; 					// reinitialize global dup_indices as an array
				if (activeContaminant == contaminantToShow) {
				} else { 							// if the currently-displayed contaminant is
													//	selected again, don't do anything! Otherwise:
					if (activeContaminant != NOT_PRESENT) { 	// if there's already a layer being displayed
					
						for (l=1; l<base.Markers.length; l++) {
							if (base.Markers[l]){ 	// if a marker exists,
								map.removeLayer(base.Markers[l]);
							};						// clear it, to wipe the map clean. 
						};
						hideLegend();				// and then hide the legend, too. 
					};
					activeContaminant = contaminantToShow;  // Store the contaminant as a global
					adjustDDText(contaminantToShow); 		// Adjust the text in the drop down menu to display the current contaminant
					showLegend(contaminantToShow);			// And display the appropriate legend
					
					$.getJSON(DATA_URL) 		// This grabs the JSON data file. MAKE SURE THE FILE IS SORTED BY 
												//	DATE IN DECREASING ORDER!!!! <--- Super important for spidering to work correctly...
					.done(function(data) {
						alert()
						// Uncomment the next line to see the full dataset in the console, super useful for debugging!
						//console.log("Data acquired! "+JSON.stringify(data)); 	// log the data in the console for debugging...
						AllData = data;						// store it in the global variable
						
						for (i=0; i<data.length; i++) { // Loop through all the rows of the data
							if (data[i][DATA_NAMES.date] == null | data[i][DATA_NAMES.date] == "" |	// if there's no date or latLng info, 
							data[i][DATA_NAMES.lat] == null | data[i][DATA_NAMES.lat] == "" |	//	ignore the point!
							data[i][DATA_NAMES.lng] == null | data[i][DATA_NAMES.lng] == "" ) {	
							} else { 						// Otherwise, check for duplicate latLngs, then plot the base markers
								if (!presentIn2dArray(dup_indices, i)[0]) {
									var matches = 0;		// If the current marker is known to be a duplicate, skip it. 
									var j = i;				// 	otherwise, check to see if it has any duplicates. This works
															//	because we loaded the data in chronological order, so the 1st
															//	element in each row of the duplicate array will be the most recent.
															// 	And the spider will extend upwards in reverse chronological order. 
									while (matches == 0 & j<data.length-1) {
										j++;				// Increment (j) to check out the next data point. 							// while there are no matches, and we're still in the data array 
															// Check to see if the current element (i) has the same latLngs
															//	as each susequent datapoint (j).
										if (Math.abs(data[i][DATA_NAMES.lat]-data[j][DATA_NAMES.lat])<EPS 
										& Math.abs(data[i][DATA_NAMES.lng]-data[j][DATA_NAMES.lng])<EPS ){
											matches++; 		// If so, increment matches to break out of the while-loop
											dup_indices.push([i,j]); 
										};					// And save the current index (i) and the 1st duplicate, (j). 			
									};
									if (matches == 1) { // If there's at least one duplicate, there may be more! 
										for (var k=j+1; k<data.length; k++) {
														// Loop through the rest of the data points, if there's a match,
														// 	at index (k), save it after (i) and (j) as [i,j,k1,k2,k3,...]
											if (Math.abs(data[i][DATA_NAMES.lat]-data[k][DATA_NAMES.lat])<EPS 
											& Math.abs(data[i][DATA_NAMES.lng]-data[k][DATA_NAMES.lng])<EPS ){
												dup_indices[dup_indices.length-1].push(k);
											};
										};
									};
								};
								
								if (!presentIn2dArray(dup_indices, i)[0]) {					// plot the base data with no history
									plotMarker("base", data, contaminantToShow, i);
								} else if (presentIn2dArray(dup_indices, i)[1][1] == 0) {	// plot the base data with historical data
									plotMarker("preSpider", data, contaminantToShow, i);
								} else {
									// Do stuff to the historic points, if you'd like, here. 
								};
							
							};
						};
						if (spiderOpen) { 											// If the spider was open already and closed,
							openSpider(AllData, spiderOpenIndex, contaminantToShow);// 	reopen it here, now colored by the new contaminant
						};
					});				
				};
				
			};
			////////////////////////////////////////////////////////////////////////////////
			////					 	plotMarker FUNCTION 						  	////
			//// 	Takes in a four arguments, "type", "data", "contam" and "data_index"////
			////	and plots  															////
			//// 	the appropriate point to the map. It also stores the marker info 	////
			//// 	(latLng, labels, popups, etc.) in a global array that can be closed ////
			//// 	by another function later. 
			////////////////////////////////////////////////////////////////////////////////
			
			function plotMarker(type, data, contam, data_index) {
				if (type == "base" | type == "preSpider") {					// If the point to plot is a base point with no historical data:
					base.Bins.push(getNextMeasuredBin(data, i)); 	// Grab the bin of the point
					var latLng = L.latLng([data[i][DATA_NAMES.lat], data[i][DATA_NAMES.lng]]); // Grab the latLng of the point
					base.Markers.push( 										// Save the appropriate marker
						L.marker(latLng, {
						icon: BASE_ICONS[base.Bins[base.Bins.length-1]],
						riseOnHover: true,
						zIndexOffset: BASE_Z_OFFSET
						})
						.on('click', function(event) { 						// When the marker is clicked	
							click_lat = event.latlng.lat; 					// Grab the latLng of the cliked point 
																			// 	(returns value of marker's center, regardless of where is clicked...)
							var j = base.Popups.map(function(a) {return a._latlng.lat}).indexOf(click_lat);
																			// this confusing line gets the index in base.Popups
																			//	of the point with the same latitude as the clicked point
																			// 	we'll use that index to access the marker, popup, and label soon. 
							if (type == "base"){ 				// if the marker is a base point without spidered points
								if(spiderOpen) {				// 	and if another spider is open
									closeSpider();				//	close that other spider.
								};
								map.openPopup(base.Popups[j]); 	// then open the popup for the clicked point.
							} else if (type == "preSpider" & !spiderOpen) { // if the point has spidered points, and there's no spider open
								openSpider(data, data_index, contam);		// 	open the spider for the clicked point!
							} else if (type == "preSpider") {				// if the point has spidered points, but there IS a spider open
								if (spiderOpenIndex == data_index) { 		// if the open spider is the clicekd point,
									map.openPopup(base.Popups[j]); 			//	show that point's popup
								} else {									// if not,
									closeSpider();							//	close the current spider
									openSpider(data, data_index, contam); 	// 	and open the clicked point's spider!
								}
							}
							
						})
					);
					base.Markers[base.Markers.length-1].bindLabel(getLabel("community", i), {
						noHide: false,										// attach labels to all the base points 
						className: "ourLabel"								//	that activate during mouseover
					});
					var popupText = getBasePopup(i);// Grab the text for the popup at data index i
					base.Popups.push(L.popup({		// Define the popup for each marker
						offset: POPUP_OFFSET})
						.setLatLng(latLng)
						.setContent(popupText)
					);
					base.Markers[base.Markers.length-1].addTo(map); // And finally, actually add the markers to the map!
				} else {						// If the point isn't being displayed, push
					base.Markers.push(false); 	// 	falses into the array, so that the indexes
					base.Popups.push(false); 	// 	are the same as in the SQL querried data. 
					base.Bins.push(false);
				}
			}		
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	getBin FUNCTION 							  	////
			//// 	Takes in a single line of a data dictionary and an array called 	////
			////	"bins". If bins begins with a 										////
			//// 	number, we'll figure out in which bin the value falls. If bins 		////
			//// 	begins with a non-number, we need to do something more complex. 	////
			//// 	Either way, getBin() returns the correct bin in which value falls.  ////
			////////////////////////////////////////////////////////////////////////////////
			
			function getBin(data, bins) {

				var values = []; 								// initialize the local array, values
				if (activeContaminant == FLUORIDE) {			// 	and push the relevant values into it,
					values.push(data[DATA_NAMES.f]);			//	depending on the contaminant to deal 
				} else if (activeContaminant == ARSENIC) { 		// 	with, which is accessed from the global,
					values.push(data[DATA_NAMES.as]);				//	"activeContaminant".
				} else if (activeContaminant == TOTAL_RISK) {
					values.push(data[DATA_NAMES.f]);
					values.push(data[DATA_NAMES.as]);
				}

				var nullCounter = 0;					// initialize a counter
				for (var i=0; i<values.length; i++) {	// count the number of nulls in the values array
					if (!values[i]) {
						nullCounter++
					}
				}
				if (nullCounter == values.length) {		// if it's full of nulls, 
					return 0;							//	return 0, the code for no data
				}
					
				
				var realBin = 1;					// Initialize the bin holder to 0. If we don't find
													// a bin >0, the bin must be 0 anyways. 
				if (typeof(bins[0]) == "number"){  	// This section deals with the case where there's
													// 	a single relevant contaminant
					for (var j=0; j<bins.length; j++) { // Loop through the bins array. If the value is
						if (values[0] > bins[j]) {	//	greater than the threshold, set the bin!
							realBin = j+2;
						};							// If the bin number hasn't been set, it means
					};								//	that the marker belongs in bin 0, the default value of realBin.
				} else if (bins[0] == "combined") { // This section deals with the case where we're 
													// 	aggregating multiple contaminants into a "risk scale."
					for(var j=1; j<bins.length; j++) {	// Loop through all the relevant contaminants (setting the bin
													//	if the value exceeds the threshold each time).
						if (realBin-1 < BINS[bins[j]].length) { // If the current bin value is less than the number of bins
							for (m=realBin-1; m<BINS[bins[j]].length; m++) { 
													// Loop through all bins in each contaminant, 
													// 	but only those above the risk level of the 
													// 	previous contaminants.
								if (values[j-1]) { 	// Quick check to make sure the value actually exists...
									if (values[j-1] > BINS[bins[j]][m]) {
													// If the value exceeds the threshold, set the bin. 
										realBin = m+2;
									};
								};
							};
						};							
					};
				} else {
					// if you have any other types of layers you'd like to include,
					//	they should go in the "else" here or in an "else if" where
					// 	you can parse the bin. Good luck!
				};
				return realBin;	
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	openSpider FUNCTION 						  	////
			//// 	Is passed the complete JSON dataset from the SQL querry and the 	////
			//// 	index of the base point that has historical duplicates and the 		////
			//// 	active contaminant. The function									////
			////	searches through the dup_indices array to find the correct row, 	////
			//// 	then plots all the points whose indices live in that row spidered.  ////
			////	dup_indices is already in reverse chronological order, so they'll 	////
			////	be plotted sequentially. When a spidered point is clicked, it's 	////
			////	popup appears. 														////
			////////////////////////////////////////////////////////////////////////////////
				
			function openSpider(data, i, contam) {
				var features = [];										// initialize a local array to store the features
				row = presentIn2dArray(dup_indices, i)[1][0];			// get the row of dup_indices where the index exists
				for (var j=0; j<dup_indices[row].length; j++) {			// loop through that row of dup_indices. I.e., loop 
																		//	through all the data-indices of points to spider
					z = dup_indices[row][j]; 							// set z to each index in turn
					var spiderBin = getBin(data[z], BINS[contam]); // set the latLng, then modify it 
					var shiftedLatLng = adjustLatLng(data[z][DATA_NAMES.lat], data[z][DATA_NAMES.lng], dup_indices[row].length, j);
					var prevShiftedLatLng = adjustLatLng(data[z][DATA_NAMES.lat], data[z][DATA_NAMES.lng], dup_indices[row].length, j-1);
																		// get the shifted latlng value of the marker
																		// then define the popup format. 
					var popupText = getBasePopup(z);					// grab the text for the popup		
					if (j==0) {											// if we're dealing with the base point of the spider
						features.push(L.marker(shiftedLatLng, {			// push the marker onto the features array
							icon: BASE_SPIDER_ICONS[spiderBin],
							zIndexOffset: SPIDER_Z_OFFSET
						}));	
					} else {
						features.push(L.marker(shiftedLatLng, {			// if we're not dealing with the base
							icon: SPIDER_ICONS[spiderBin],				// also push the marker onto the features array.
							zIndexOffset: SPIDER_Z_OFFSET
						}));		
						var popupText = getLabel("hist", 0)+popupText;	// adjust the popup text to note "historical data"
						features.push(L.polyline([shiftedLatLng, prevShiftedLatLng],{
							color: POLY_COLOR,							// push a polyline connecting the current
							weight: POLY_WEIGHT,									// 	point and the previous one onto the 
							opacity: POLY_OPACITY									// 	featurs array
						}));
					};
					if (j==0) {						// if we're dealing with the base point
						var marker_index = 0;		// 	set the marker index to 0
					} else {						// otherwise, the markers are odd and 
						var marker_index = 2*j-1;	// 	their polylines are the following evens
						var polyline_index = 2*j;
					};	
					features[marker_index].bindLabel(getLabel("year", z), {
						noHide: true,				// bind labels displaying the date
						className: "yearLabel",		// 	permanently next to each spidered point
						offset: SPIDER_LABEL_OFFSET						
					});
					features[marker_index].bindPopup(popupText, {
						offset: POPUP_OFFSET 		// bind the appropriate popup to each marker
					});
					if (polyline_index) {					// if there is a polyline (i.e. not the 0th point)
						features[polyline_index].bindLabel(getLabel("community", z),{
							className: "ourLabel"	// bind a label to the polylines as well, displaying community name
						});
					};
				}
				
				var shiftedLatLng = adjustLatLng(data[z][DATA_NAMES.lat], data[z][DATA_NAMES.lng], dup_indices[row].length, j);
				var prevShiftedLatLng = adjustLatLng(data[z][DATA_NAMES.lat], data[z][DATA_NAMES.lng], dup_indices[row].length, j-1);
				features.push(L.marker(shiftedLatLng, {	// get the newest shifted point values
					icon: X_ICON,						// 	to plot the x-out icon at the top
					zIndexOffset: X_OFFSET				// 	of the spider stack. 
				}).on('click', function() {				// When the x-out is clicked,
					closeSpider();						//	close the spider. 
				}));
				
				features.push(L.polyline([shiftedLatLng, prevShiftedLatLng],{
					color: POLY_COLOR,					// push a polyline connecting the x-out
					weight: POLY_WEIGHT,							//	button and the oldest spidered point.
					opacity: POLY_OPACITY
				}).bindLabel(getLabel("community", z),{	// attach the community label to the polyline
					className: "ourLabel"
				}));
														// Finally, add the whole spider featureGroup to the map!
				spiderFeatures = L.featureGroup(features).addTo(map);
				spiderOpenIndex = i;					// set the gloabl spider index 
				spiderOpen = true;						//	and status. Wooohooo! Spider plotted!
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	window.onclik FUNCTION 						  	////
			//// 	When the user clicks in the window, this function executes. It is  	////
			//// 	used to toggle the state (show/hide) of the dropdown menu. You 		////
			////	almost definitely don't need to mess with this, unless you want 	////
			////	something new to happen anytime the user clicks in the window...	////
			////////////////////////////////////////////////////////////////////////////////
			
			window.onclick = function(event) {
				if (!event.target.matches('.dropbtn')) { 				// if the user's clikced the dropdown button
					var dropdowns = document.getElementsByClassName("dropdown-content");
					for (var i=0; i<dropdowns.length; i++) { 		// loop through dropdown menu
						var openDropdown = dropdowns[i]; 				// if the dropdown menu is showing
						if (openDropdown.classList.contains('show')) { 	// remove show (so that it hides)
							openDropdown.classList.remove('show');
						};
					};
				};
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	adjustDDText FUNCTION 						  	////
			//// 	Takes in a contaminant and adjusts the display text in the dropdown ////
			////	menu to that contaminant with a downwards pointing triangle. 		////
			////////////////////////////////////////////////////////////////////////////////
			
			function adjustDDText(contam) {
				var pointDown = '\xa0\xa0\xa0\u25BC'; 	// The value of a downwards pointing arrow
														// 	preceeded by 3 spaces. 
				document.getElementById('DDHeader').textContent = CONTAMINANTS[contam]+pointDown;
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	toggleDD FUNCTION 							  	////
			//// 	changes the classList property to show on the drop down menu 	    ////
			////////////////////////////////////////////////////////////////////////////////
			
			function toggleDD(){
				document.getElementById("mapSelector").classList.toggle("show");
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	getBasePopup FUNCTION 					  		////
			//// 	Takes in an index and returns the base popup text format used.		////
			////////////////////////////////////////////////////////////////////////////////
			
			function getBasePopup(i) {
				var date = String(AllData[i][DATA_NAMES.date]).split("/", 3);
			
				var day = String(date[0]);
				var month = MONTHS[Number(date[1])];
				var year = String(date[2]);

				var docPath = AllData[i][DATA_NAMES.docs];
				var docLink;
				if(docPath) {
					docLink = "<a href="+ docPath +" target='_blank'>"+SEE_MORE+"</a>";
				} else {
					docLink = ""
				}
				
				if (!AllData[i][DATA_NAMES.f] | AllData[i][DATA_NAMES.f] == "") {
					f_numb = NO_DATA_MSG;
				} else {
					f_numb = AllData[i][DATA_NAMES.f];
				};
				
				if (!AllData[i][DATA_NAMES.as] | AllData[i][DATA_NAMES.as] == "") {
					as_numb = NO_DATA_MSG;
				} else {
					as_numb = AllData[i][DATA_NAMES.as];
				};
				
				var pop = "<dl><h2>" + AllData[i][DATA_NAMES.name] + "</h2>"	// This text will be displayed
					+ "<b>"+DATE+"</b>"												//	in the popup for this point.
					+ "<dt>" + day + "-" + month + "-" + year + "</dd>"
					+ "<br><br>"
					+ "<b>"+CONTAMINANTS[0]+" (mg/L)</b>"
					+ "<dt>" + f_numb + "</dd>"
					+ "<br><br>"
					+ "<b>"+CONTAMINANTS[1]+" (&mu;g/L)</b>"
					+ "<dt>" + as_numb + "</dd>"
					+ "<br><br>"
					+ docLink
				return pop;
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	adjustLatLng FUNCTION 						  	////
			//// 	Takes in a lat, lng, total number of points to spider, and the index////
			////	of this particular point. Returns an L.latLng object with the 		////
			////	location at which to plot the marker. 								////
			////																		////
			////	Algorithm: 	x -> x - (X_STRETCH/total_pts)*i^2						////
			////				y -> y - Y_STRETCH*i									////
			////////////////////////////////////////////////////////////////////////////////
			
			function adjustLatLng(lat, lng, total_pts, i) { 				
				var latLng = L.latLng([lat, lng]);					// build a latLng object
				var ll_point = map.latLngToContainerPoint(latLng);	// convert to container point with [x, y] coords, then shift
				var x = ll_point.x - (X_STRETCH/total_pts)*i*i; 	// get the shifted x
				var y = ll_point.y - Y_STRETCH*i;					//	 and y.
				var shiftedLatLng = map.containerPointToLatLng(L.point([x, y])); // Turn the shifted components back to a L.latLng object.
				return shiftedLatLng;
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	presentIn2dArray FUNCTION 					  	////
			//// 	Takes in a 2D array and a value, and returns an array of the form 	////
			//// 	[exists?, [index0, index1]] where "exists?" is a boolean, true if 	////
			//// 	the value exists in the array, at the coordinates [index0][index1].	//// 
			////																		////
			////	THIS FUNCTION ONLY WORKS IF THERE ARE NO REPEATS. OTHERWISE IT WILL	////
			////	RETURN THE 1ST INSTANCE OF value IN array.							////
			////////////////////////////////////////////////////////////////////////////////
			
			function presentIn2dArray(array, value) {
				var exists = false; 					// if we don't find value in array, we'll return false. 
				var index = [NOT_PRESENT, NOT_PRESENT];					// if we don't find value in array, we'll return [-1,-1] as it's coordinates.
				for (var a=0; a<array.length; a++) {		// loop through each subArray
					if (array[a].indexOf(value) > NOT_PRESENT) { // if the value exists in that subArray
						exists = true; 					// set exists
						index = [a, array[a].indexOf(value)]; 	// and set the indices
					};
				};
				return [exists, index]; 			
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////						getNextMeasuredBin FUNCTION	 					////
			////																		////
			////	Takes in the full dataset and index. If the point isn't a spider,	////
			////	returns 0. Otherwise, it returns the bin of the next most recent, 	////
			////	non-zero data point at the same location. If there isn't one, 
			//// 	returns 0 as well. 
			////////////////////////////////////////////////////////////////////////////////
			
			
			function getNextMeasuredBin(data, i) {
				var nextBin = 0;
				var bin;
				if (!presentIn2dArray(dup_indices, i)[0]) {
					nextBin = getBin(data[i], BINS[activeContaminant]);
				} else {
					dup_row = dup_indices[presentIn2dArray(dup_indices, i)[1][0]];
					for (var j=dup_row.length-1; j>=0; j--){
						bin = getBin(data[dup_row[j]], BINS[activeContaminant])
						if (bin != 0) {
							nextBin = bin;
						}					
					}
				};
				return nextBin;
				
			
			
			
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	getLabel FUNCTION 							  	////
			//// 	Takes in the type of label to plot (string) and the index of the 	////
			////	marker's data in the global data array, AllData. Returns the string ////
			////	that will be contained in the label. 								////
			////////////////////////////////////////////////////////////////////////////////
	
			function getLabel(type, i) {
				if (type == "year") {
					return "\xa0"+String(AllData[i][DATA_NAMES.date].split('/',3)[2]);		
				} else if (type == "community") {
					str = String(AllData[i][DATA_NAMES.name]);
					str = str.split(" ")
					var newStr = "";
					var lineCount = 1;
					for (var i=0; i<str.length; i++) {
						tempNewStr = newStr+"\xa0"+str[i]
						if(tempNewStr.length>MAX_LABEL_LINE_CHARS*lineCount & i!=0) {	
							newStr = newStr+"\xa0\n\xa0"+str[i];
						} else {
						newStr = tempNewStr;
						}
					};
					return "\xa0"+newStr+"\xa0";
				} else if (type == 'hist') {
					return OLD_DATA_MSG;
				};
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					  	hideLegend FUNCTION	 						  	////
			//// 			This function hides any div legends that may be open.		////
			////////////////////////////////////////////////////////////////////////////////
			
			function hideLegend() {
				document.getElementById('fluoride_legend').style.display = 'none';
				document.getElementById('arsenic_legend').style.display = 'none';
				document.getElementById('risk_legend').style.display = 'none';
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					  	showLegend FUNCTION	 						  	////
			//// 	This function shows the div legend for the relevant contaminant.	////
			////////////////////////////////////////////////////////////////////////////////
			
			function showLegend(contam) { 
				if (contam == FLUORIDE) {
					document.getElementById('fluoride_legend').style.display = 'block';
				} else if (contam == ARSENIC) {
					document.getElementById('arsenic_legend').style.display = 'block';
				} else if (contam == TOTAL_RISK) {
					document.getElementById('risk_legend').style.display = 'block';
				};
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	closeSpider FUNCTION 						  	////
			//// 	Closes all points stored in the global var spiderFeatures.			////
			////////////////////////////////////////////////////////////////////////////////
			
			function closeSpider() { 				
				if (spiderFeatures) {				// if spiderFeatures exists (if a spider is open)
					map.removeLayer(spiderFeatures)	// 	then remove it!		
				};						
				spiderOpen = false;					// reset the global flag that the spider is closed
			}
			
			////////////////////////////////////////////////////////////////////////////////
			////					 	removePoint FUNCTION 						  	////
			//// 			Removes the point stored at the index i.					////
			////////////////////////////////////////////////////////////////////////////////
			
			function removePoint(i) {
				map.removeLayer(base.Markers[i]); 
			}
	
			
		</script>
		
	</body>
</html>
			
